package ru.stimmax.cotlincouse.lessons.lesson15.homework15

import ru.stimmax.cotlincouse.lessons.lesson11.max

//Это класс контейнера. Он абстрактный, это означает, что нельзя создавать экземлпяр этого класса,
// он нужен только для того, чтобы быть основой для подклассов.
//Создай подклассы этого контейнера, которые будут добавлять строку material (или коллекции или словари строк)
// в какое-то определённое место (места).

abstract class Materials {
    private val materials = mutableListOf<String>() // создали мутабельный список материалов

    fun addMaterial(material: String) { // функция принамет в себя 1 материал
        materials.add(material) // добавляет этот материал в список материалов
    }
    fun extractMaterials(): List<String> { // функция которая на выходе отдает немутабельный лист
        val extracted = materials.toList() // создается переменная которая копирует список и превращает лист в немутабельный
        materials.clear() // очищает мутабельный лист
        return extracted // возвращает немутабельный лист
    }
    fun printContainer() {
        materials.forEachIndexed { index, layer -> // перебираем элементы по индексам и его значениям
            println("[$index]: $layer") // выводим в консоль индекс: значение каждого элемента
        }
    }
}

// Первый класс должен вставлять строку на дно контейнера (должно появиться под индексом 0)
// нужно: 1. Очистить список, 2- вставить новый элемент на дно, 3- заполнить список очищенными значниями

class AddNewElements(): Materials() {
    fun addNewElements(newElements: String){ // создали функцию которая добавляет новый элемент, принимает в себя новый элемент
        val funExtracted = extractMaterials() // создали переменную которая вызывает функцию extractMaterials.
        // funExtracted теперь содержит копию элементов списка materials, а сам materials теперь пустой
        addMaterial(newElements) // добавили новый элемент в мутабельный список materials. Т.к он был пуст из вызова предыдущего метода, то новый
        // элемент встанет на 1-е место.
        funExtracted.forEach { addMaterial(it) } // Говорим пройдись по немутабельному списку элементов funExtracted и вызови addMaterial для каждого элемента
        // addMaterial - добавляет элементы в другой мутабельный список, который мы ранее очистили и добавили в него новый элемент.

    }

}

// Второй класс должен получать список строк и вставлять их в начало контейнера но поочерёдно с теми данными,
// которые уже есть. То-есть, наш список должен появиться в контейнере по индексам 0, 2, 4 и так далее.
class AddMaterials(): Materials() {
    fun newMaterial(items: List<String>) { // функция добавляет новые элементы. Принимает в себя список новых элементов

        val newElements = extractMaterials() // Очистили старый контейнер и создали его копию

        val maxIndex = max(items.lastIndex, newElements.lastIndex)
        // создали новую переменную maxIndex в которой вызывается функция max
        // функция max сравнивает два числа — индексы последних элементов двух списков — и возвращает максимальный.

        for (i in 0..maxIndex) { // цикл в котором говорим пройтись по индексам от 0 до maxIndex
            if (i < items.lastIndex) { // если i входит в список items - добавляем его в контейнер
                addMaterial(items[i])
            }
            if (i < newElements.lastIndex) { // если i входит в newElements - добавляем его в контейнер
                addMaterial(newElements[i])
            }
        }

    }
}

//Третий класс при добавлении строки должен отсортировать весь список метиралов в алфавитном порядке
// включая добавляемый материал.
class AddMaterial(): Materials() { // создали класс наследник

    fun addMaterials(listMaterial: String) {// создали функцию которая принимает строку в себя

        val result = ((extractMaterials() + listMaterial).sorted()) // добавили к немутабельному списку новую строку
        // тем самым создали новый немутабельный список уже со строкой которую добавили и отсортировали по порядку

        result.forEach { addMaterial(it) }// прошлись по списку result и добавили его элементы
        // в мутабельный список который очистили ранее с помощью extractMaterials

    }
}

//Четвёртый класс должен принимать словарь (ключи и значения строки).
// Каждая пара ключа и значения должна попадать в контейнер следующим образом - ключ в начало,
// значение в конец. Таким образом в начале должны быть ключи в обратном порядке,
// потом существующие материалы, потом все значения.

class InsertMapMaterials: Materials() {
    fun insert(items: Map<String,String>) {
        val materials = items.keys.reversed() + extractMaterials() + items.values// создали новый немутабельный список состоящий из перевенутых ключей + копия мутабельного списка + значения словаря
        materials.forEach { addMaterial(it) } // добавили список в контейнер.
    }
}

