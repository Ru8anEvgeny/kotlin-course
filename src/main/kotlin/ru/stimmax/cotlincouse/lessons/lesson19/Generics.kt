package ru.stimmax.cotlincouse.lessons.lesson19
// дженерики - это механизм обобщения который позволяет писать универсальный код пригодный для работы
// с разными типами данных


class Box<T>(val item: T)
// определили класс и в <> определили некий тип. В скобках может быть просто буква или просто слово.
// таким образом говорим что этот класс работает с разными типами.


fun main() {

    val appleBox = Box("Apple")// создали объект класса и положили туда строку
    val intBox = Box(1)// создали объект класса и положили туда число

    val appleBoxItem = appleBox.item
    val intBoxItem = intBox.item

    appleBox.item.length // можем вызывать методы для текста
    intBoxItem.minus(2)// так же можем использовать методы для инта

    val secondOrNullLength: Int? = secondOrNull(listOf("a", "bcd", "c"))?.length
    // вызываем secondOrNull и передаем туда список и просим вывести его длинну
    println(secondOrNullLength) // выведет 3

}

// можем использовать дженерики в функциях. Когда пишем функцию дженерик объявляем перед названием функции
fun <S> secondOrNull(list: List<S>): S? { // говорим что функция принимает какой-то лист с типом S
    // и на выходе будет тип S или нулл
    return list.getOrNull(1) // говорим верни элемент по индексу и если его нет верни нулл
}


// можем ограничивать дженерик определенным типом
fun <T: Number> sum(a: T, b: T): Double { // ограничили определенным типом
    // говорим что Т может быть типа Number. Number - это интерфейс
    // В аргументы можем передавать все объекты классов которые имплементируют интерфейс Number
    // Number - эт астрактный класс для работы с числами разных типов. Соттветсвтенно у а и б будут доступны
    // все методы этого класса
    return a.toDouble() + b.toDouble()
}


// можем поставить ограничения в класса
class GenericIterator<T : Number, R : Iterable<T>>(
    // создали класс в котором есть дженерики, 1-й Т - ограничен классом Number
    // 2-й ограничен Iterable и в ограничении используется 1-й дженерик
    // Iterable - тип который проводит итерации, списки множетсва и тп.
    // Таким образом у нас получается, что класс может пинимать в себя числа и списки из чисел.
    private val argument: T, // некий агумент который может быть числом любого типа
    private val elements: R // некий аргумент который может быть списком или множеством с числовым типом
) {
    fun printElements() {
        for (e in elements) {
            println(
                e.toString()
                    .repeat(argument.toInt())
            )
        }
    }
}